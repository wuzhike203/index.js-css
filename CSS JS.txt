// 16-09-26 
    杜绝使用<meta http-equiv="X-UA-Compatible" content="IE=7" /> 兼容 ie8;
    15. 避免兼容性属性的使用, 比如text-shadow || css3的相关属性;
    16. 减少使用影响性能的属性, 比如position:absolute || float ;

// js
    Example Source Code jQuery变量要求首字符为'_', 其他与原生JavaScript 规则相同, 如: _iTaoLun;
    另, 要求变量集中声明, 避免全局变量.

// img
    图片规范
    　　1. 所有页面元素类图片均放入img文件夹, 测试用图片放于img/demoimg文件夹;
    　　2. 图片格式仅限于gif || png || jpg;
    　　3. 命名全部用小写英文字母 || 数字 || _ 的组合，其中不得包含汉字 || 空格 || 特殊字符；
           尽量用易懂的词汇, 便于团队其他成员理解;
           另: 命名分头尾两部分, 用下划线隔开, 比如ad_left01.gif || btn_submit.gif;
    　　4. 在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间;
    　　5. 可以使用半透明的png图片(若使用, 请参考css规范相关说明);
    　　6. 运用css sprite技术集中小的背景图或图标, 减小页面http请求,
           但注意, 请务必在对应的sprite psd源图中划参考线, 并保存至img目录 下.

// 开发及测试工具约定
　　测试工具: 前期开发仅测试FireFox  & IE7 & IE8 ,
    后期优化时加入Opera & Chrome & Safari;
　　建议测试顺序: FireFox-->IE8-->IE7 -->Opera-->Chrome-->Safari, 
        建议安装firebug及IE Tab Plus插件.
    4:IE6访问页面时判断提供升级链接
    <!--[if lte IE 6]>
    <div id="ie6-warning">您正在使用 Internet Explorer 6，在本页面的显示效果可能有差异。建议您升级到 <a href="http://www.microsoft.com/china/windows/internet-explorer/" target="_blank">Internet Explorer 8</a> 或以下浏览器： <a href="http://www.mozillaonline.com/">Firefox</a> / <a href="http://www.google.com/chrome/?hl=zh-CN">Chrome</a> / <a href="http://www.apple.com.cn/safari/">Safari</a> / <a href="http://www.operachina.com/">Opera</a>
    </div>
    <script type="text/javascript">
    function position_fixed(el, eltop, elleft){
    // check if this is IE6
    if(!window.XMLHttpRequest)
    window.onscroll = function(){
    el.style.top = (document.documentElement.scrollTop + eltop)+"px";
    el.style.left = (document.documentElement.scrollLeft + elleft)+"px";
    }
    else el.style.position = "fixed";
    }
    position_fixed(document.getElementById("ie6-warning"),0, 0);
    </script>
    <![endif]-->

// 16-10-09 08:37:34 
    css 样式规则
    1、先定位置：
        1.1 水平居中有2中方式
            a、块 ： margin: auto
            b、inline 和 inline-block : 父元素text-align: center;

    2、再定宽度和高度
        2、1 定义内部元素的区域优先


    3、垂直居中有两种方式：
        3、1 inline: vertical-align: middle;
        3、2 line-height = height :
                                比较适合一致对齐
        3、3 padding: 上下一致:  [[div1]  [div2]                 [div3]  ]
                                比较适合两端分别对齐的时候

// 16-10-10 15:02:53 
    1、body ： 一般只设最小宽度：1050px;
    2、背景 ： 一般为rgba(0, 0, 0, 0.3), 即：黑色的30%;
    3、弹窗高度：一般最大为580px; 再大就下拉条

// 16-10-10 17:06:31 
    css 模块化：
    思想：网页是由一个一个对象构成。对象是由众多的元素组成
    1、物体对象1：具有非常明显特征的对象区域
        // 其用于css 的 className 
        // 应：具有此对象的特性。
        // 应：不属于公众样式

    2、容器对象2：用于承载其他对象(包括对象1)
        #1、css的编写以类为主，尽量不用元素标签和ID， 
        #2、来避免css样式的交叉作用
        #3、应考虑到如果内容元素的宽度或高度超出容器对象时，如何处理。

    3、一组对象，具有很多共同的部分，也有部分差异
        应仿照 类和继承的写法

// 16-10-11 
    // 滚动条插件   使用方法和注意事项
    1、 jquery.mCustomScrollbar.css
    2、 jquery.mCustomScrollbar.min.js
        jquery.mousewheel.min.js 
    3、	对要作用的元素
        3.1 设置max-height,
        3.2 使用函数：mCustomScrollbar({theme: "minimal"});
        如：
            $("elem").mCustomScrollbar({theme: "minimal"});	

        #此元素必须设置max-height,否则不起作用。

    4、滚动条的位置在块的border处，故需要右边的margin-right: 10px。
        // 此为建议

// 16-10-16 09:40:19 
    text-align:     作用于外，外框中 文本 的对齐方式
    vertical-align: 作用于内，内联元素 在 外框中的垂直对齐方式。

// 16-09-29 15:57:53 
    IE8 absolute问题

// 16-09-28 00:03:08 
    button 与 a作为按钮的区别
    button: 文字自动对中(上下和左右)
            自动添加border
    a: 文字不自动对中

// 16-09-27 22:00:44 
    两个(ul>li*8), 怎么都对不齐，
    而且是越到后面，歪的越狠。
    // 原因：
        一个里面的li:{float: left;}
        另一个里面的li:{display: inline-block;}

// 16-10-18 11:08:16 
    float ：元素之间无间距
    inline-block: 元素之间有间距(目前还不知道什么原因造成的)

// 16-10-18 13:28:00 
    即使元素的透明度为0，任然可以被点击。
    但display:none, 和 visible:hidden 却不行。

// 16-10-18 15:20:33 
    图片压缩：https://tinypng.com/

// 16-10-18 15:28:53 
    setTimeout(function, time)
    // function : 指向一个函数的指针
    对于匿名函数： function(){}
    对于 function name(){
    
        }
        : name

// 16-10-19 11:44:54 
    当position: absolute; left: 0px; 时，
    // 元素与父元素的边界border对齐，不是与父元素的内容对齐.
    #从这点讲，定义父元素组形状时，尽量用width, 少用padding。

    当父元素 overflow: hidden ; 时，
    子元素不超过父元素的border, 而不是内容。

// 16-10-20 15:52:28 
    table th 的作用
    1、td的宽度由对应的th标签的宽度决定。
    2、 <tr>
            <th></th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        假如：a: 确定了第一个th的宽度为100px,
              b: table的总宽度为：500px
              则：剩下两列的宽度为：(500-100)/2
    3、一个table 最好只 允许一行 th 。
        // 如果出现多行th。则第一行的th对宽度起作用。
    4、对某行的tr作用样式，可能在这行中每个td或th上都显示相同的重复样式。
        例如：对tr应用背景图案，则在每一个td上都出现相同的图案。

// 16-10-20 17:01:34  
    Content Delivery Network
    内容分发网络CDN

    内容分发网络将网站内容发布到最接近用户的边缘节点，使网民可就近取得所需内容，提高网民访问的响应速度和成功率，同时能够保护源站。解决由于地域、带宽、运营商接入等问题带来的访问延迟高问题，有效帮助站点提升访问速度。

// 16-10-24 12:36:09 
    checkbox已设置为checked--true-但不勾选问题解决方法（只第一次勾选有效）
    // 使用jquery prop() 代替 attr()

// 16-10-24 13:37:38 
    IE css hack:

    color:white;        /* 所有的 */
    color: green\9\0;   /* IE9+ */
    +color: red;        /* IE7- */
    #1、\9\0的顺序：不可更换
    #2、*color:red; 必须放在最后，否则IE7无法识别。

//16-10-24 14:58:22 
    360 极速模式 不支持 writing-mode: tb-lr 和 tb-rl :

// 16-10-24 15:13:46 
    media query
    screen and (max-device-aspect-ratio: 10/12);

// 16-10-27 09:01:02 
    #!!p标签中不能放置div标签

// 16-10-27 09:44:38 
    1、checkbox, radio 没有change 事件。
        //通过点击事件，检查其值
    2、change事件对应文本域(text, textarea)和select
    3、select事件对应文本域(text, textarea)

//16-10-27 14:41:06 
    margin 上下合并
    只有普通文档流中垂直相邻的块元素才会发生marign垂直方向的合并。
    #inline-block, float, absolute均会失效。

// 16-10-28 16:17:20 
    //chrome滚动条样式：
    // chrome滚动条是以伪对象的方式使用
    .test::-webkit-scrollbar{
        // 基础
        background-color: transparent;
        width: 5px;
    }
    .test::-webkit-scrollbar-track{
        // 轨道
        background-color:#eee;
        border-radius: 5px;
    }
    .test::-webkit-scrollbar-thumb{
        // 滑块
        background-color:#00aff0;
        border-radius: 5px;
    }
    .test::-webkit-scrollbar-thumb:hover {
        // 鼠标移动到滑块时
        background-color:#9c3;
    }
    .test::-webkit-scrollbar-thumb:active {
        // 鼠标拖动滑块时
        background-color:red;
    }

// 16-11-01 11:10:33 
    // px em rem
        任意浏览器的默认字体高都是16px。
        所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。
        为了简化font-size的换算，需要在css中的body选择器中声明:
            Font-size=62.5%，或者 font-size: 10px;
            这就使em值变为 16px*62.5%=10px, 
        这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。
    #chrome 中最小字体：12px(即使设置的字体低于此值，浏览器也会按照最小字体12px显示的)。

    //EM特点 
    1. em的值并不是固定的；
    2. em会继承父级元素的字体大小。
    // rem
        是CSS3新增的一个相对单位（root em，根em）.
        这个单位与em有什么区别呢？
            区别在于使用rem为元素设定字体大小时，仍然是相对大小，
            但相对的只是HTML根元素。

// 16-11-04 08:47:38 
    只有fixefox 支持 text-decoration的复合写法:
    text-decoration: text-decoration-line || text-decoration-style || text-decoration-color
    例如：text-decoration: line-through solid red;
    //其他浏览器仅仅支持：
        text-decoration: text-decoration-line;
        例如：text-decoration: line-through;

// 16-11-04 09:32:37 
    // background-clip
    chrome 支持:
        -webkit-background-clip: text;
        backgrund-clip: border-box;
        //即：对于text，必须带上-webkit-
              对于其他属性，必须不带-webkit-
    fixefox 支持：
        -webkit-background-clip:text 
        background-clip:text
        background-clip: border-box;

// 16-11-10 10:28:21 
    // transfrom
    所谓变换，就是把对象上 
            每个点的坐标值 
        按照一定的规则 
            变为另一个坐标值
        的过程。
    transform: matrix(a, b, c, d, e, f)
    例如：对于对象上某一点(x, y), 其新坐标为(x1, y1):
        a   c   e       x       ax+cy+e         x1
        b   d   f   *   y   =   bx+dy+f <==>    y1 
        0   0   1       1       0 +0 +1         1
    特例：
    1、当a=1, b=0, c=0, d=1时
        x1 = x+e,
        y1 = y+f,
        相当于translate(e,f)
    2、当a=2, b=0, c=0, d=2, e=0, f=0时
        x1 = 2x,
        y1 = 2y,
        相当于scale(2)

// 16-11-25 11:42:28 什么情况下用table:
    当需要自适应的时候
    1、 不管有1,2 或 3项等时，要求均分整个空间。
    2、 当有左右项时，一边的高度增加时，另一边也要增加时。

// 16-12-05 11:19:17 拖动事件
    按一般的理解：鼠标移动才叫拖动，
    但有时，即使人没有移动鼠标，由于震动等原因，浏览器会自动判断鼠标在移动了。
    解决方案：判断鼠标移动的位置。大于某一个小数值，才叫 “真移动”.

// 16-12-05 11:29:11 正则表达式
    1、当使用正则构造函数新建一个正则实例时，构造函数会先对字符串转义一次,如：
    var reg = new RegExp("\d+");
    字符串"\d+"被传入后，实际变成"d+",
    即：reg = /d+/;
    2、[.] == [\.], 即：及时在中括号里面，"\"也是转义的
    3、     RegExp 构造函数 
                    ↓
                RegExp 实例 → 字符串
        3.1 当一个regexp 实例作用于一个字符串时，如果带有g标志，
            则下一次查找从上一次查找到的字符串的下一个位置开始,
        // 如果找到字符串，返回带有index和input属性的数组。
        // index: 找到的字符串在原字符串中的位置。
        // input: 正则的字面量表示。
        // 数组的第一项是与整个正则表达式匹配的字符串。
        // 以后的每一个项是与铺货组匹配的字符串(如果有的话)
        3.2 每一个regexp实例的行为反应到实例中的lastIndex: 下一次查找的起点
        3.3 同时每一个regexp实例的行为都会反应到RegExp的静态属性中：
        ---------------------------------------------------------------
            长属性名        说明
        ---------------------------------------------------------------
            input           最近一次要匹配的字符串
            lastMatch       最近一次的匹配项
            lastParen       最近一次的捕获组
            leftContext     input字符串中lastMatch之前的文本
            rightContext    input字符串中lastMatch之后的文本

// 16-12-12 16:00:10
	1、右键选择
        -webkit-user-select: none;
        #极大地降低chrome浏览器性能
        -moz-user-select: none;
        #对firefox影响不大
    2、记录版本之间的变化 往往比 记录变化的结果 更有效!
    3、网页显示流程：
        3.1 把html解析为dom树
        3.2 把css解析为cssom
        3.3 把 dom树和cssom 合成 渲染树
        3.4 生成布局(layout), 即: 将渲染树进行平面合成。(flow)
        3.5 绘制(painter)
        // 前面3步往往很快，一般卡在第四步。
        // "生成布局"(flow)和"绘制"(paint)这两步，合称为"渲染"(render)
        // 重排 必然 重绘；
        导致重排(reflow)的操作(即：导致布局发生变化的操作)
        a. 修改dom
        b. 改变元素的位置。
        // 仅仅导致重绘的操作(即：不影响布局)
        a. 改变元素的颜色

        总结：提高网页的性能，就是要减少重排(reflow)和重绘(repainter)的频率和成本
            // 尤其是重排(重排比重绘花费的时间要多很多)
        一、降低频率
            1、尽可能的把多个操作集中处理，然后一次执行，避免多次渲染(render)
                例如：
                    div.style.color = 'blue';
                    div.style.marginTop = '30px';
                    // 上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。

                    div.style.color = 'blue';
                    var margin = parseInt(div.style.marginTop);
                    div.style.marginTop = (margin + 10) + 'px';
                    // 上面代码对div元素设置背景色以后，
                    // 第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。

            // 一般来说，样式的写操作之后，
            // 如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。
                offsetTop/offsetLeft/offsetWidth/offsetHeight
                scrollTop/scrollLeft/scrollWidth/scrollHeight
                clientTop/clientLeft/clientWidth/clientHeight
                getComputedStyle()

            // 所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。
                // bad
                div.style.left = div.offsetLeft + 10 + "px";
                div.style.top = div.offsetTop + 10 + "px";

                // good
                var left = div.offsetLeft;
                var top  = div.offsetTop;
                div.style.left = left + 10 + "px";
                div.style.top = top + 10 + "px";

            #一般的规则是：
                // 样式表越简单，重排和重绘就越快。
                // 重排和重绘的DOM元素层级越高，成本就越高。
                // table元素的重排和重绘成本，要高于div元素

            #提高性能的技巧
                1、不要一条条地改变样式，
                    而要通过改变class，或者csstext属性，
                    一次性地改变样式
                2、尽量操作离线DOM, 克隆DOM, 隐藏DOM等，
                    然后再用这些DOM替换原始节点 或 显示等。
        二、降低成本
            1、 重排和重绘的DOM元素层级越高，成本就越高。
                table元素的重排和重绘成本，要高于div元素
            2、 innerHTML的成本 要稍低于 原始dom操作
                (注意：在dom数比较大的时候成本同样很高)
            3、在某个element元素的内容发生变化时，
                如果只有少量的dom发生操作，
                #操作单个dom的成本要远低于内容替换(innerHTML)

// 16-12-22 14:25:33 
    让元素的高度与浏览器高度一致
    html, body{height: 100%;}
    div{min-height: 100%; height:auto;}
