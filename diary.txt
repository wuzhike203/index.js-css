// 在这里收集优秀的网站
1 Linux公社 : https://linux.linuxidc.com/




// 18-05-07 21:24:59 
腾讯高级架构师1天面试10人，揭秘腾讯面试秘诀




刚刚面试完一个耿直 boy:
    问他之前某个项目最困难的点是什么，为什么，回复：“因为我不会”
    问他在学习实现某个算法的时候有什么心得体会，回复：“觉得很舒畅。。。”
好吧（摊手.jpg ）。。。。。






从过完年开始，我们就在招人，从各个渠道找。在招聘过程中，有了这些想法，和大家分享，希望其中有地方对大家有启发：


1.自我学习和成长的能力非常关键。
    创业公司面临的最大的确定性，就是未来的不确定性。面对未知的未来，最重要的能力是学习能力。
因此几乎每个应聘者在讲完过去做的某个主要项目之后，我都会问：如果现在的你重做一遍当时的项目，你觉得哪些地方能够做得更好？ 这类的问题，很难临时想出好的答案。只有你真的有不断反省同时不断学习的习惯的时候，才能够很自然地回答出你思考已久的答案。


2.面试的过程其实也是我的学习过程
    从优秀的应聘者身上可以学到很多知识和经验，即使本次不适合，也期待未来有机会合作。对于特别欣赏的，会分享很多对于产品和未来的规划，会和他一起讨论，听取他的建议。
所以即使这次面试你可能没被选中，也不要失望，当作是结交了一个朋友，未来很有可能能够合作。


3.不要因为学历问题而自卑，不要因为任何问题自卑。只要你在以下方面展示出了你的能力，那些都是浮云：
    a. 各类竞赛（对于学生来说：ACM/ICPC, 数模,各类数理竞赛，对于已工作的人来说：topcoder)
    b. 在 GitHub 或者类似平台有自己的开源项目(有自己的开源项目并且长期维护，本身就是你个人兴趣和能力的体现。如果这个项目很受欢迎，那就更好了）
    c. 长期高质量向优秀的开源库贡献代码
    d. 在主流开发者社区是优质贡献者：比如 stackoverflow
    e. 有自己的优质的技术博客
    而以上这些点，都是可以掌握在你自己手里的。
    举个例子： 有一位我很欣赏的开发者，大学因为不喜欢学校的课程，并没有拿到毕业证。 然而自己对编程非常热爱，做过某创业企业的 CTO，每日处理上亿级别接口请求；自己喜欢机器学习，于是不断自 己学习研究，结合自己的兴趣做了一个开源项目，拿到了 10 万的日 PV。现在在机器学习这块有了很深刻的认知和丰富 的经验，过年期间被好几个企业追着要给 Offer。


4.不要毫无准备地去面试。
    包括但不限于：
    你要去应聘的公司是什么公司，他们需要什么样的人；
    如果你认为你和他们的需求有差距，你有什么具体的计划来弥补这个差距，让他们可以放心选你？
    你要展示的关键履历是什么，对方可能提什么问题；
    你觉得自己的主要优势是什么，你应该如何去突出它；
    你的主要劣势是什么，如果被问到了，你应该如何回答？


// 18-05-07 21:31:20 
一位 IT 男的 多年工作经验总结！！

1、分享第一条经验：“学历代表过去、能力代表现在、学习力代表未来。”其实这是一个来自国外教育领域的一个研究结果。相信工作过几年、十几年的朋友对这个道理有些体会吧。但我相信这一点也很重要：“重要的道理明白太晚将抱憾终生！”所以放在每一条，让刚刚毕业的朋友们早点看到哈！

2、一定要确定自己的发展方向，并为此目的制定可行的计划。不要说什么，“我刚毕业，还不知道将来可能做什么？”，“跟着感觉走，先做做看”。因为，这样的观点会通过你的潜意识去暗示你的行为无所事事、碌碌无为。一直做技术，将来成为专家级人物？向管理方向走，成为职业经理人？先熟悉行业和领域，将来自立门户？还是先在行业里面混混，过几年转行做点别的？这很重要，它将决定你近几年、十年内“做什么事情才是在做正确的事情！”。

3、软件开发团队中，技术不是万能的，但没有技术是万万不能的！在技术型团队中，技术与人品同等重要，当然长相也比较重要哈，尤其在MM比较多的团队中。在软件项目团队中，技术水平是受人重视和尊重的重要砝码。无论你是做管理、系统分析、设计、编码，还是产品管理、测试、文档、实施、维护，多少你都要有技术基础。算我孤陋寡闻，我还真没有亲眼看到过一个外行带领一个软件开发团队成功地完成过软件开发项目，哪怕就一个，也没有看到。倒是曾经看到过一个“高学历的牛人”（非技术型）带一堆人做完过一个项目，项目交付的第二天，项目组成员扔下一句“再也受不了啦！”四分五裂、各奔东西。那个项目的“成功度”大家可想而知了。

4、详细制定自己软件开发专业知识学习计划，并注意及时修正和调整（软件开发技术变化实在太快）。请牢记：“如果一个软件开发人员在1、2年内都没有更新过自己的知识，那么，其实他已经不再属于这个行业了。”不要告诉自己没有时间。来自时间管理领域的著名的“三八原则”告诫我们：另外的那8小时如何使用将决定你的人生成败！本人自毕业以来，平均每天实际学习时间超过2小时。

5、书籍是人类进步的阶梯，对软件开发人员尤其如此。书籍是学习知识的最有效途径，不要过多地指望在工作中能遇到“世外高人”，并不厌其烦地教你。对于花钱买书，我个人经验是：千万别买国内那帮人出的书！我买的那些家伙出的书，100%全部后悔了，无一本例外。更气愤的是，这些书在二手市场的地摊上都很难卖掉。“拥有书籍并不表示拥有知识；拥有知识并不表示拥有技能；拥有技能并不表示拥有文化；拥有文化并不表示拥有智慧。”只有将书本变成的自己智慧，才算是真正拥有了它。

6、不要仅局限于对某项技术的表面使用上，哪怕你只是偶尔用一、二次。“对任何事物不究就里”是任何行业的工程师所不应该具备的素质。开发Windows应用程序，看看Windows程序的设计、加载、执行原理，分析一下PE文件格式，试试用SDK开发从头开发一个Windows应用程序；用VC＋＋、Delphi、Java、.Net开发应用程序，花时间去研究一下MFC、VCL、J2EE、.Net它们框架设计或者源码；除了会用J2EE、JBoss、Spring、Hibernate等等优秀的开源产品或者框架，抽空看看大师们是如何抽象、分析、设计和实现那些类似问题的通用解决方案的。试着这样做做，你以后的工作将会少遇到一些让你不明就里、一头雾水的问题，因为，很多东西你“知其然且知其所以然”！

7、在一种语言上编程，但别为其束缚了思想。“代码大全”中说：“深入一门语言编程，不要浮于表面”。深入一门语言开发还远远不足，任何编程语言的存在都有其自身的理由，所以也没有哪门语言是“包治百病”的“灵丹妙药”。编程语言对开发人员解决具体问题的思路和方式的影响与束缚的例子俯拾皆是。我的经验是：用面对对象工具开发某些关键模块时，为什么不可以借鉴C、C51、汇编的模块化封装方式？用传统的桌面开发工具（目前主要有VC++、Delphi）进行系统体统结构设计时，为什么不可以参考来自Java社区的IoC、AOP设计思想，甚至借鉴像Spring、Hibernate、JBoss等等优秀的开源框架？在进行类似于实时通信、数据采集等功能的设计、实现时，为什么不可以引用来自实时系统、嵌入式系统的优秀的体系框架与模式？为什么一切都必须以个人、团队在当然开发语言上的传统或者经验来解决问题？？？“他山之石、可以攻玉”。

8、养成总结与反思的习惯，并有意识地提炼日常工作成果，形成自己的个人源码库、解决某类问题的通用系统体系结构、甚至进化为框架。众所周知，对软件开发人员而言，有、无经验的一个显著区别是：无经验者完成任何任务时都从头开始，而有经验者往往通过重组自己的可复用模块、类库来解决问题（其实这个结论不应该被局限在软件开发领域、可以延伸到很多方面）。这并不是说，所有可复用的东西都必须自己实现，别人成熟的通过测试的成果也可以收集、整理、集成到自己的知识库中。但是，最好还是自己实现，这样没有知识产权、版权等问题，关键是自己实现后能真正掌握这个知识点，拥有这个技能。

9、理论与实践并重，内外双修。工程师的内涵是：以工程师的眼光观察、分析事物和世界。一个合格的软件工程师，是真正理解了软件产品的本质及软件产品研发的思想精髓的人（个人观点、欢迎探讨）。掌握软件开发语言、应用语言工具解决工作中的具体问题、完成目标任务是软件工程师的主要工作，但从软件工程师这个角度来看，这只是外在的东西，并非重要的、本质的工作。学习、掌握软件产品开发理论知识、软件开发方法论，并在实践中理解、应用软件产品的分析、设计、实现思想来解决具体的软件产品研发问题，才是真正的软件工程师的工作。站在成熟理论与可靠方法论的高度思考、分析、解决问题，并在具体实践中验证和修正这些思想与方式，最终形成自己的理论体系和实用方法论。

10、心态有多开放，视野就有多开阔。不要抱着自己的技术和成果，等到它们都已经过时变成垃圾了，才拿出来丢人现眼。请及时发布自己的研究成果：开发的产品、有创意的设计或代码，公布出来让大家交流或者使用，你的成果才有进化和升华的机会。想想自己2000年间开发的那些Windows系统工具，5、6 年之后的今天，还是那个样子，今天流行的好多Windows系统工具都比自己的晚，但进化得很好，且有那么多用户在使用。并且，不要保守自己的技术和思想，尽可能地与人交流与分享，或者传授给开发团队的成员。“与人交换苹果之后，每个人还是只有一个苹果；但交换思想之后，每个人都拥有两种思想”，道理大家都懂，但有多少人真正能做到呢？

11、尽量参加开源项目的开发、或者与朋友共同研制一些自己的产品，千万不要因为没有钱赚而不做。网络早已不再只是“虚拟世界”，网上有很多的开源项目、合作开发项目、外包项目，这都是涉猎工作以外的知识的绝好机会，并且能够结识更广的人缘。不要因为工作是做ERP，就不去学习和了解嵌入式、实时、通信、网络等方面的技术，反过来也是一样。如果当别人拿着合同找你合作，你却这也不会，那也不熟时，你将后悔莫及。

12、书到用时方恨少，不要将自己的知识面仅仅局限于技术方面。诺贝尔经济学奖得主西蒙教授的研究结果表明：“对于一个有一定基础的人来说，他只要真正肯下功夫，在6个月内就可以掌握任何一门学问。”教育心理学界为感谢西蒙教授的研究成果，故命名为西蒙学习法。可见，掌握一门陌生的学问远远没有想象的那么高难、深奥。多方吸取、广泛涉猎。极力夯实自己的影响圈、尽量扩大自己的关注圈。财务、经济、税务、管理等等知识，有空花时间看看，韬光养晦、未雨绸缪。

13、本文的总结与反思：

A：不要去做技术上的高手，除非你的目标如此。虽然本文是关于提高软件开发知识的建议，做技术的高手是我一向都不赞同的。你可以提高自己的专业知识，但能胜任工作即止。

B：提高软件知识和技术只是问题的表面，本质是要提高自己认识问题、分析问题、解决问题的思想高度。软件专业知识的很多方法和原理，可以很容易地延伸、应用到生活的其它方面。

C：在能胜任工作的基础上，立即去涉猎其它领域的专业知识，丰富自己的知识体系、提高

自己的综合素质，尤其是那些目标不在技术方面的朋友。




// 18-05-07 21:27:00 
    1 之前的工作经历怎么分类?
        从中都掌握了什么？
    2 之后的学习(或者提升技能)的计划




// ---- 18-05-10 00:24:30 
    #高性能JS代码
    虽然没有高性能代码的绝的定义，但是我们确实有一个以用户为中心的性能模型，
    我们可以把它作为参考:RAIL模型。
    1 R: Respond(响应)
        如果你的应用能在100毫秒内响应用户操作，用户就能感觉到立即响应。
        这适用于可点击的元素，但不适用于滚动或拖动。
    2 A: Animate （动画）
        在60Hz的显示器上，我们希望在动画和滚动时，以每秒60帧的帧为目标。
        结果是每帧大约16ms。在16ms的预算中，您实际拥有8~10ms来完成所有的工作，
        其余部分被浏览器内部和其他的差异占用。
    3 I: Idle work
        如果你有一个昂贵的且持续运行的任务，请确保将其分割为较小的块，
        以允许主线程对用户输入做出反应。你不应该有任务延迟超过50ms的用户输入。
    4 L: Load （加载）
        你应该将页面加载定位在1000毫秒以内。所有事情结束了，你的用户开始变得焦躁等待。
        这在移动设备上是一个非常难达到的目标，因为它涉及到页面交互，
        不只是把它绘制在屏幕和和可滚动的页面上。在实践中，它甚至更少：


    // -- 
    1 JS 解析时间与 JS 包大小虽然不一定是线性比例，但是你装载的 JavaScript 肯定是越少越好。

    2 你使用的每个JS框架(React，Vue，Angular，Preact …) 都是另一个抽象层次 (除非它是一个预编译的框架，比如 Svelte )。它不仅会增加您的包大小，而且还会减慢你的代码，因为你不会直接与浏览器对话。

    3.1 他们可能使用 CSS transitions ，合成属性和requestAnimationFrame()，他们仍然在主线程的JS上运行。他们基本上只是每 16ms 用内联样式修改你的 DOM ，因为他们没有别的办法可以做到这一点。你需要确保你所有的JS都会在每帧 8ms 以内完成，以保持动画的平滑。
    3.2 CSS animations 和 transitions ，会在 GPU 的主线上运行，如果能够高效执行，则不会导致重新布局(relayouts)/重排(reflows)。

    // -- 尽量减少包的大小
    尝试装载少量的JS。你的项目可能不需要整个 Lodash 库。你绝对需要使用JS框架吗？如果是，你有没有考虑过使用 React 以外的东西？如 Preact 或 HyperHTML ，它们的大小不到 React 的 1/20 。你需要 TweenMax 的滚动到顶部的动画吗？npm 的便利性 和 框架中孤立组件有一个缺点：开发人员对问题的第一反应就是把更多的 JS 扔在项目中。当你只有一把锤子的时候，一切看起来像钉子。

    当你清除哪些无用的代码，并且减少 JS 装载时，试着把它更聪明一些。当你需要的时候，在把你需要的东西装载进来。

    Webpack 3具有 惊人 的能力，称为代码分割和动态导入。它不需要将所有的JS模块打包到一个单独的 app.js 包中，它可以使用 import() 语法自动地分割代码，并异步加载。

    你不需要使用框架，组件和客户端路由来获得它的好处。 假设你有一个驱动 .mega-widget 的复杂代码片断，可以在任意数量的页面上。你可以简单地在你的主JS文件中编写下如下内容：

    然后就是 编译代码 和 polyfills 的事情了。 如果你正在编写现代 JavaScript (ES6+)，你可能使用 Babel 将其转换为 ES5 兼容代码。由于所有的冗余，转译不仅增加了文件的大小，而且还增加了复杂性，与原生 ES6+ 代码相比，ES5 兼容代码的 性能也有所下降 。

    除此之外，您可能正在使用 babel-polyfill 包 和 whatwg-fetch 来修复旧浏览器中缺失的功能。那么，如果你使用 async/await 编写代码，你也使用 generators（生成器）编译时所需要包括的 regenerator-runtime …

    关键是，为了支持更老的浏览器，你的 JS 包中几乎添加了10万字节的数据，这不仅是一个巨大的文件尺寸，而且对于解析和执行来说也是一个巨大的开销。

    然而，这对于使用现代浏览器的人来说就是毫无意义的惩罚。我使用的方法是 Philip Walton 在 这篇文章 中提到的方法，是创建两个单独的包，并有条件地加载它们。通过 Babel 的 babel-preset-env 使这个问题变得简单。例如，你有一个专门用于支持 IE 11 的独立包，另一个没有 polyfills 的独立包专门用于支持最新版本的现代浏览器。

    // 总结：尽量减少不必要的代码




// ---- 18-05-10 00:47:39 
    浏览器缓存

    浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：

    先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；

    当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；

    强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；

    区别是，强缓存不对发送请求到服务器，但协商缓存会。

    当协商缓存也没命中时，服务器就会将资源发送回客户端。

    当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

    当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

    强缓存

    Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）

    Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）

    协商缓存

    Last-Modified（值为资源最后更新时间，随服务器response返回）

    If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）

    ETag（表示资源内容的唯一标识，随服务器response返回）

    If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）
